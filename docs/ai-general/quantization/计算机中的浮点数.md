# 计算机中数据表示

我们学习计算机知识时，经常听到「定点数」和「浮点数」，它们之间有什么区别？

平时说到整数，我们就说它是一个定点数，说到小数，就说它是一个浮点数，这种说法是正确的吗？

# 定点数

这篇文章，我们先来看一下，「定点数」究竟与整数和小数有什么关系。

## 什么是定点数？

要想理解什么是「定点数」，首先，我们需要理解「定点」究竟是什么意思？

我们都知道，数字既包括整数，又包括小数，而小数的精度范围要比整数大得多，所以如果我们想在计算机中，既能表示整数，也能表示小数，关键就在于这个**小数点**如何表示？

于是人们想出一种方法，即**约定计算机中小数点的位置**，且这个位置固定不变，小数点前、后的数字，分别用二进制表示，然后组合起来就可以把这个数字在计算机中存储起来，这种表示方式叫做「定点」表示法，用这种方法表示的数字叫做「定点数」。

也就是说「定」是指固定的意思，「点」是指小数点，**小数点位置固定**即定点数名字的由来。

## 定点数如何表示数字？

既然定点数只是表示数字的一种方式，那试想，它可以表示整数吗？可以表示小数吗？

答案是肯定的。

定点数如果要表示整数或小数，分为以下三种情况：

1. 纯整数：例如整数100，小数点其实在最后一位，所以忽略不写
2. 纯小数：例如：0.123，小数点固定在最高位
3. 整数+小数：例如1.24、10.34，小数点在指定某个位置

对于前两种情况，纯整数和纯小数，因为小数点固定在最低位和最高位，所以它们用定点数表示时，原理是相同的，只需要把整数部分、小数部分，按照十进制转二进制的规则，分别转换即可。

而对于整数 + 小数的情况，用定点表示时，需要**约定**小数点的位置，才能在计算机中表示。

## 定点数表示纯整数和纯小数

听闻不如一见，我们举几个例子。先来看一下定点数如何表示纯整数和纯小数？

对于纯整数100，由于小数点固定在最低位，假定我们以 1 个字节（8 bit）表示，用定点数表示如下（D为十进制缩写，B为二进制缩写）：

```
100(D) = 01100100(B)
```

对于纯小数 0.125，由于小数点固定在最高位，同样以 1 个字节（8 bit）表示，用定点数表示如下：

```
0.125(D) = 0.00100000(B)
```

从以上例子可以看出，这 2 种情况用定点数表示都比较简单，按照十进制转为二进制规则，即可得到结果。

## 定点数表示整数+小数

我们再来看定点数如何表示整数 + 小数？

这种情况下，我们需要先约定小数点的位置。

依旧以 1 个字节（8 bit）为例，我们可以约定**前 5 位**表示整数部分，**后 3 位**表示小数部分。

对于数字 1.5 用定点数表示就是这样：

```
1.5(D) = 00001 100(B)
```

数字 25.125 用定点数表示就是这样：

```
25.125(D) = 11001 001(B)
```

这就是用定点数表示一个小数的方式。这里再总结一下这个过程：

1. 在有限的 bit 宽度下，先约定小数点的位置
2. 整数部分和小数部分，分别转换为二进制表示
3. 两部分二进制组合起来，即是结果

在计算机中，用定点数表示一个数字的方法，是不是很简单？

但是有没有发现一个问题，我们约定了前 5 位表示整数部分，后 3 位表示小数部分，此时这个整数部分的二进制最大值只能是 11111，即十进制的 31，小数部分的二进制最大只能表示 0.111，即十进制的 0.875。

如果我们想要表示更大范围的值，怎么办？

1. 扩大 bit 的宽度：例如使用 2 个字节、4 个字节，这样整数部分和小数部分宽度增加，表示范围也就变大了
2. 改变小数点的位置：小数点向后移动，整个数字范围就会扩大，但是小数部分的精度就会越来越低，没有办法表示类似 0.00001 这种高精度的值

由此我们发现，不管如何约定小数点的位置，都会存在以下问题:

- 数值的表示范围有限（小数点越靠左，整个数值范围越小）
- 数值的精度范围有限（小数点越靠右，数值精度越低）

总的来说，就是用定点数表示的小数，不仅数值的范围表示有限，而且其精度也很低。要想解决这 2 个问题，所以人们就提出了使用「浮点数」的方式表示数字，关于浮点数的表示方法，我们会在下一篇文章进行讲解。

虽然定点数表示数字，存在以上说的这些问题，但也只是在表示小数的场景下。如果只是用于表示整数，还是非常方便的。

所以，现代计算机中一般使用定点数来表示整数。

# 浮点数

在上一篇文章中，我们主要介绍了在计算机中使用定点数表示数字的方式。

简单回顾一下，简单来说，用定点数表示数字时，会约定小数点的位置固定不变，整数部分和小数部分分别转换为二进制，就是定点数的结果。

但用定点数表示小数时，存在数值范围、精度范围有限的缺点，所以在计算机中，我们一般使用「浮点数」来表示小数。

这篇文章，我们就来详细看一下浮点数到底是如何表示小数的，以及浮点数的的范围和精度有多大。

## 什么是浮点数

我们知道，数学中并没有浮点数的概念，虽然小数看起来像浮点数，但从不这么叫。那为什么计算机中不叫小数而叫浮点数呢？

因为资源的限制，数学中的小数无法直接在计算机中准确表示。为了更好地表示它，计算机科学家们发明了浮点数，这是对小数的近似表示。维基百科中关于[浮点数](https://en.wikipedia.org/wiki/Floating-point_arithmetic) 的概念说明如下：

> The term floating point refers to the fact that a number’s radix point (decimal point, or, more commonly in computers, binary point) can float; that is, it can be placed anywhere relative to the significant digits of the number.

也就是说浮点数是相对于定点数而言的，表示小数点位置是浮动的。其实，浮点数是采用科学计数法的方式来表示的，例如十进制小数 8.345，用科学计数法表示，可以有多种方式：

```python
8.345 = 8.345 * 10^0
8.345 = 83.45 * 10^-1
8.345 = 834.5 * 10^-2
...
```

看到了吗？用这种科学计数法的方式表示小数时，小数点的位置就变得「漂浮不定」了，这就是相对于定点数，浮点数名字的由来。

使用同样的规则，对于二进制数，我们也可以用科学计数法表示，也就是说把基数 10 换成 2 即可。

## 浮点数如何表示数字？

我们已经知道，浮点数是采用科学计数法来表示一个数字的，具体来说，浮点数是指用符号、尾数、基数和指数这四部分来表示的小数，它的格式可以写成这样：

```python
V = (-1)^S * M * R^E
```

其中各个变量的含义如下：

- S：符号位，取值 0 或 1，决定一个数字的符号，0 表示正，1 表示负
- M：尾数，用小数表示，例如前面所看到的 8.345 * 10^0，8.345 就是尾数
- R：基数，表示十进制数 R 就是 10，表示二进制数 R 就是 2
- E：指数，用整数表示，例如前面看到的 10^-1，-1 即是指数

如果我们要在计算机中，用浮点数表示一个数字，只需要确认这几个变量即可。

假设现在我们用 32 bit 表示一个浮点数，把以上变量按照一定规则，填充到这些 bit 上就可以了：

![img](https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2020/12/16090678516816.jpg)

假设我们定义如下规则来填充这些 bit：

- 符号位 S 占 1 bit
- 指数 E 占 10 bit
- 尾数 M 占 21 bit

按照这个规则，将十进制数 25.125 转换为浮点数，转换过程就是这样的（D代表十进制，B代表二进制）：

1. 整数部分：25(D) = 11001(B)
2. 小数部分：0.125(D) = 0.001(B)
3. 用二进制科学计数法表示：25.125(D) = 11001.001(B) = 1.1001001 * 2^4(B)

所以符号位 S = 0，尾数 M = 1.001001(B)，指数 E = 4(D) = 100(B)。

按照上面定义的规则，填充到 32 bit 上，就是这样：

![img](https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2020/12/16090693834968.jpg)

浮点数的结果就出来了，是不是很简单？

但这里有个问题，我们刚才定义的规则，符号位 S 占 1 bit，指数位 E 占 10 bit，尾数 M 占 21 bit，这个规则是我们拍脑袋随便定义出来的。

如果你也想定一个新规则，例如符号位 S 占 1 bit，指数位 E 这次占 5 bit，尾数 M 占 25 bit，是否也可以？当然可以。

按这个规则来，那浮点数表示出来就是这样：

![img](https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2020/12/16090693834973.jpg)

我们可以看到，指数和尾数分配的位数不同，会产生以下情况：

1. 指数位越多，尾数位则越少，其表示的范围越大，但精度就会变差，反之，指数位越少，尾数位则越多，表示的范围越小，但精度就会变好
2. 一个数字的浮点数格式，会因为定义的规则不同，得到的结果也不同，表示的范围和精度也有差异

早期人们提出浮点数定义时，就是这样的情况，当时有很多计算机厂商，例如IBM、微软等，每个计算机厂商会定义自己的浮点数规则，不同厂商对同一个数表示出的浮点数是不一样的。

这就会导致，一个程序在不同厂商下的计算机中做浮点数运算时，需要先转换成这个厂商规定的浮点数格式，才能再计算，这也必然加重了计算的成本。

那怎么解决这个问题呢？业界迫切需要一个统一的浮点数标准。

## 浮点数标准

直到1985年，IEEE 组织推出了浮点数标准，就是我们经常听到的 **IEEE754 浮点数标准**，这个标准统一了浮点数的表示形式，并提供了 2 种浮点格式：

- 单精度浮点数 float：32 位，符号位 S 占 1 bit，指数 E 占 8 bit，尾数 M 占 23 bit
- 双精度浮点数 float：64 位，符号位 S 占 1 bit，指数 E 占 11 bit，尾数 M 占 52 bit

![img](https://polarisxu.studygolang.com/posts/basic/imgs/float-point03.png)

为了使其表示的数字范围、精度最大化，浮点数标准还对指数和尾数进行了规定：

1. 尾数 M 的第一位总是 1（因为 1 <= M < 2），因此这个 1 可以省略不写，它是个**隐藏位**，这样单精度 23 位尾数可以表示了 24 位有效数字，双精度 52 位尾数可以表示 53 位有效数字
2. 指数 E 是个无符号整数，表示 float 时，一共占 8 bit，所以它的取值范围为 0 ~ 255。但因为指数可以是负的，所以规定在存入 E 时在它原本的值加上一个**中间数** 127，这样 E 的取值范围为 -127 ~ 128。表示 double 时，一共占 11 bit，存入 E 时加上中间数 1023，这样取值范围为 -1023 ~ 1024。

除了规定尾数和指数位，还做了以下规定：

- 指数 E 非全 0 且非全 1：规格化数字，按上面的规则正常计算
- 指数 E 全 0，尾数非 0：非规格化数，尾数隐藏位不再是 1，而是 0(M = 0.xxxxx)，这样可以表示 0 和很小的数
- 指数 E 全 1，尾数全 0：正无穷大/负无穷大（正负取决于 S 符号位）
- 指数 E 全 1，尾数非 0：NaN(Not a Number)

<img src="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2020/12/16090749848677.jpg" alt="3" style="zoom:150%;" />

## 标准浮点数的表示

有了这个统一的浮点数标准，我们再把 25.125 转换为标准的 float 浮点数：

1. 整数部分：25(D) = 11001(B)
2. 小数部分：0.125(D) = 0.001(B)
3. 用二进制科学计数法表示：25.125(D) = 11001.001(B) = 1.1001001 * 2^4(B)

所以 S = 0，尾数 M = 1.001001 = 001001(去掉1，隐藏位)，指数 E = 4 + 127(中间数) = 135(D) = 10000111(B)。填充到 32 bit 中，如下：

![img](https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2020/12/16090678516830.jpg)

这就是标准 32 位浮点数的结果。

如果用 double 表示，和这个规则类似，指数位 E 用 11 bit 填充，尾数位 M 用 52 bit 填充即可。

## 浮点数为什么有精度损失？

我们再来看一下，平时经常听到的浮点数会有精度损失的情况是怎么回事？

如果我们现在想用浮点数表示 0.2，它的结果会是多少呢？

0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止，在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。

```python
0.2 * 2 = 0.4 -> 0
0.4 * 2 = 0.8 -> 0
0.8 * 2 = 1.6 -> 1
0.6 * 2 = 1.2 -> 1
0.2 * 2 = 0.4 -> 0（发生循环）
...
```

所以 0.2(D) = 0.00110…(B)。

因为十进制的 0.2 无法精确转换成二进制小数，而计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。

## 浮点数的范围和精度有多大？

最后，我们再来看一下，用浮点数表示一个数字，其范围和精度能有多大？

以单精度浮点数 float 为例，它能表示的最大二进制数为 +1.1.11111…1 * 2^127（小数点后23个1），而二进制 1.11111…1 ≈ 2，所以 float 能表示的最大数为 2^128 = 3.4 * 10^38，即 float 的表示范围为：-3.4 * 10^38 ~ 3.4 * 10 ^38。

它能表示的精度有多小呢？

float 能表示的最小二进制数为 0.0000….1（小数点后22个0，1个1），用十进制数表示就是 1/2^23。

用同样的方法可以算出，double 能表示的最大二进制数为 +1.111…111（小数点后52个1） * 2^1023 ≈ 2^1024 = 1.79 * 10^308，所以 double 能表示范围为：-1.79 * 10^308 ~ +1.79 * 10^308。

double 的最小精度为：0.0000…1(51个0，1个1)，用十进制表示就是 1/2^52。

从这里可以看出，虽然浮点数的范围和精度也有限，但其范围和精度都已非常之大，所以在计算机中，对于小数的表示我们通常会使用浮点数来存储。



## Reference

- http://kaito-kidd.com/2018/07/23/computer-system-fixed-point/
- http://kaito-kidd.com/2018/08/08/computer-system-float-point/
